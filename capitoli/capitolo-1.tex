% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex
% !TEX spellcheck = it-IT

%**************************************************************
\chapter{Introduzione}
\label{cap:introduzione}
%**************************************************************

%Introduzione al contesto applicativo.\\

%\noindent Esempio di utilizzo di un termine nel glossario \\
%\gls{api}. \\

%\noindent Esempio di citazione in linea \\
%\cite{site:agile-manifesto}. \\

%\noindent Esempio di citazione nel pie' di pagina \\
%citazione\footcite{womak:lean-thinking} \\

%**************************************************************
\section{L'azienda}

VIC è stata fondata da Alessio Bisutti che, dopo aver sviluppato una lunga esperienza
nel campo ispettivo, ha deciso di costituire una società in grado di offrire ai propri clienti un servizio professionale, chiaro ed affidabile, appoggiandosi alle nuove tecnologie.
Si occupa di controlli per grandi ordini, sia di materie prime che di semi-lavorati, di
cui individua e riporta eventuali danni, carenze nella spedizione e non conformità con
quanto ordinato.
VIC viene fondata a Venezia 7 anni fa come piccola società di ispezione locale. Fin dall'inizio, l'obiettivo principale di VIC è stato la riduzione del tempo tra ispezione e reporting al cliente. Ora l'obiettivo è raggiunto, perchè VIC sta fornendo ai suoi clienti tutti i risultati e le informazioni importanti in tempo reale, senza alcun ritardo, grazie agli investimenti fatti nel campo della tecnologia e delle applicazioni mobili.

%**************************************************************
\section{L'idea}

I più importanti obbiettivi del controllo qualità effettuato durante un ispezione sono il determinare la corretta forma, peso, quantità e dimensioni degli oggetti da esaminare.\\
Gli ispettori possono scattare fotografie, prendere appunti e sfruttare la loro esperienza per fornire stime accurate; si è manifestata però la necessità di affiancare queste ultime a dei dati quanto più possibile oggettivi e rapidi da ottenere.\\
Da qui nasce l'idea di fornire agli ispettori uno strumento informatico in grado di effettuare queste stime. Grazie alla ricostruzione computerizzata resa disponibile dai \emph{Tango device} sarà possibile non solo visualizzare su uno schermo il modello 3D del soggetto della ispezione, ma anche ottenere ulteriori dati utili quali:
\begin{itemize}
	\item Una stima del volume, e se necessario del peso, dell'oggetto.
	\item L'esito del confronto dell'oggetto con un modello ideale, per evidenziare eventuali danni o deformazioni.
\end{itemize}
Con il prototipo realizzato durante lo \emph{stage} sono rese disponibili solamente le funzionalità di ricostruzione dell'oggetto e calcolo (approssimato) del volume.\\
Le operazioni troppo computazionalmente intensive da effettuare su tablet, quali il filtraggio e \emph{meshing} dei punti acquisiti, sono state delegate ad un \emph{backend server} che effettui le elaborazioni necessarie ed invii i risultati al richiedente, mentre all'applicativo per tablet è stato affidato il compito di aquisire e visualizzare un oggetto sotto forma di 'Nuvola di Punti' e poterne esaminare la \emph{mesh} ottenuta.

%**************************************************************
\section{Cos'è Project Tango}

Project Tango è un \emph{tablet} sperimentale prodotto da \emph{Google} in grado di scandire tridimensionalmente l'ambiente circostante e di tracciare la propria posizione rispetto ad esso. Ciò è possibile attraverso il ricco hardware di cui è dotato (si veda la figura \ref{fig:tango_hardware}), tra cui:
\begin{itemize}
\item una fotocamera RBG-IR\\
\item una fotocamera \emph{Fisheye}\\
\item un sensore di profondità IR\\
\item accelerometro e giroscopio\\
\end{itemize}

\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{varie/tango-hardware.png} 
    \caption{L' \emph{hardware} di \emph{Project Tango}}
    \label{fig:tango_hardware}
\end{figure}

\noindent
Project Tango è quindi specificamente pensato per sviluppare applicazioni che necessitano di comprendere ed estrapolare informazioni dal mondo reale (ad es. realtà aumentata).
Le funzionalità del \emph{tablet} sono accessibili attraverso le \emph{Tango API}, le \emph{API} ufficiali per lo sviluppo di applicazioni \emph{Tango}.


%**************************************************************
\section{Il Prodotto - lato client}

L'applicazione su \emph{tablet} prodotta realizza, seppur non ancora in maniera completa, le esigenze richieste. \\
La sua realizzazione ha incontrato molte problematiche talvolta critiche e difficili da prevedere. Per questo durante lo sviluppo sono stati implementati più prototipi, al fine di esplorare le potenzialità e soprattutto i limiti del \emph{tablet} e delle \emph{Tango API}. \\
Lo scopo principale dell'applicazione lato \emph{tablet} è quello di rilevare una corretta 'Nuvola di Punti' dell'oggetto che si vuole esaminare.\\
Una 'Nuvola di Punti' è una descrizione matematica di un oggetto tridimensionale ottenuta tramite un insieme, il più possibile fitto, di punti che lo compongono, definiti dalle loro coordinate (\textbf{x},\textbf{y},\textbf{z}) rispetto ad un fissato sistema di riferimento. \\
Tale rappresentazione, riferita spesso d'ora in poi con il più elegante termine inglese \emph{Point Cloud}, è facilmente comprensibile all'utente se visualizzata come in figura \ref{fig:point_cloud_example}.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/point_cloud_example.png} 
    \caption{Esempio di \emph{Point Cloud}: un cestino cilindrico}
   \label{fig:point_cloud_example}
\end{figure}

\subsection{Primo prototipo: Cloude}
Il prototipo denominato \emph{Cloude} risponde all'esigenza di catturare più \emph{Point Cloud} da più angolazioni in modo da ricostruire l'oggetto scansionato sovrapponendo i dati acquisiti. \emph{Cloude} è il risultato di più prototipazioni precedenti effettuate dallo stagista che ha iniziato il progetto prima di me e con cui ho strettamente collaborato.\\
Il prototipo permette quindi di acquisire più \emph{Point Cloud} in successione, ognuno dei quali verrà adeguatamente ruotato e traslato rispetto allo spostamento del \emph{tablet}, in modo che la sovrapposizione degli stessi vada infine a ricostruire tutte le parti dell'oggetto esaminato.\\
Una sola acquisizione da una certa angolazione non può infatti comprendere un oggetto nella sua interezza, come dimostrato nelle figure \ref{}
 è necessario ricostruire passo per passo un unico \emph{Point Cloud} rappresentante l'oggetto completo.
Sulla base dei risultati di \emph{Cloude} ho iniziato il mio lavoro sulla parte di elaborazione lato \emph{server} dei \emph{Point Cloud} acquisiti; questo è stato inoltre il punto di inizio per lo sviluppo dei prototipi successivi in collaborazione con l'altro stagista.

\subsection{Secondo prototipo: Samba}
Il secondo prototipo parte dai risultati ottenuti con \emph{Cloude} e ne migliora prestazioni e precisione, aggiungendo alcune funzionalità utili. \\
\emph{Samba} affronta e risolve alcuni problemi del prototipo precedente, come il \emph{"Drifting"} e alcuni problemi prestazionali dovuta alla mole elevata di dati acquisiti. Introduce inoltre la funzionalità di visualizzazione delle \emph{mesh} elaborate dal \emph{server}.

\subsubsection{Drift correction}
Il prototipo precedente, seppur funzionale, generava ricostruzioni di scarsa qualità, afflitte soprattutto dal problema del \emph{"drifting"}. Il \emph{drifting} è un problema comune nelle applicazioni di realtà aumentata, che come \emph{Project Tango} usano la tecnica del \emph{Motion Tracking}, cioè aggiornano costantemente la propria posizione relativamente alle coordinate acquisite nella posizione precedente, mantenendo così una storia dei movimenti del \emph{device} rispetto all'ambiente circostante.\\
Ad ogni aggiornamento della posizione è normale ed inevitabile che la misurazione, per quanto precisa, introduca un piccolo errore; la catena di errori sommati porta quindi col passare del tempo ad un'importante discrepanza tra la posizione stimata del \emph{device} e la sua posizione reale, come evidenziato in figura \ref{fig:drift_correction}
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=0.9\columnwidth]{varie/Drift_Correction.png} 
    \caption{\emph{Drifting} nel \emph{Motion Tracking}}
    \label{fig:drift_correction}
\end{figure}
\newline
Per ovviare in parte a questo problema \emph{Samba} utilizza una tecnica chiamata \emph{Drift Correction} ch si appoggia sulle funzionalità di \emph{Area Learning} dei \emph{device Tango}.\\
L' \emph{Area Learning} consiste nella capacita del dispositivo di estrarre dallo spazio fisico che sta analizzando una serie di punti significativi (o \emph{key features}), facilmente riconoscibili, e di salvare tali informazioni per confrontarle con le successive acquisizioni. In questo modo il dispositivo è capace di riconoscere un'area precedentemente visitata, e può quindi applicare le necessarie correzioni alla popria stima della traiettoria, di qui il nome \emph{Drift Correction}.\\
Con l'implementazione di questa funzionalità è necessario, prima di iniziare la ricostruzione di un \emph{Point Cloud}, riprendere l'oggetto e i suoi dintorni per un po' di tempo e da diverse angolazioni, in modo da permettere al \emph{tablet Tango} di costruire una mappa, detta \emph{Area description}, dell'area circostante, e di stabilizzare la traiettoria stimata con le informazioni acquisite.\\
I risultati si vedono confrontando queste due ricostruzioni di una scatola, vista dall'alto (fig. \ref{fig:no_drift_correction} e fig. \ref{fig:with_drift_correction}), rispettivamente senza e con \emph{Drift correction}.
\begin{figure}[htp] 
    \centering
    \subfloat[Ricostruzione senza \emph{Drift correction}]{%
        \includegraphics[width=0.47\columnwidth]{varie/no_drift_correction.png} 
    	%\caption{Ricostruzione senza \emph{Drift correction}}
    	\label{fig:no_drift_correction}
    }%
    \hfill%
    \subfloat[Ricostruzione con \emph{Drift correction}]{%
        \includegraphics[width=0.47\columnwidth]{varie/with_drift_correction.png} 
    	%\caption{Ricostruzione con \emph{Drift correction}}
    	\label{fig:with_drift_correction}
    }%
    \caption{Benefici della \emph{Drift Correction}}
\end{figure}
\newline
Come si nota in figura \ref{fig:with_drift_correction} il risultato non è ancora ottimale, infatti un lato della scatola appare sdoppiato e spostato di qualche centimetro; si tratta di un problema di \emph{ghosting} di cui verrà trattato più avanti.

\subsubsection{Prestazioni}
Il prototipo precedente presentava due problemi prestazionali principali:
\begin{itemize}
\item La ricostruzione passo per passo del \emph{Point Cloud} finale era troppo lenta
\item La mole dei dati trattati al sovrapporsi di più \emph{Point Cloud} diventava proibitiva
\end{itemize}
\noindent
Il primo problema si presentava utilizzando i metodi forniti dalla libreria \emph{Tango} per trasformare le coordinate relative dei punti in coordinate assolute per permetterne la giusta sovrapposizione. Tale metodo, seppur di facile utilizzo, diventava troppo dispendioso all'aumentare delle dimensioni del \emph{Point Cloud}, che raggiunge facilmente gli 80.000 punti.\\
Per risolvere il problema viene quindi creata, per ogni \emph{Point Cloud}, una \emph{matrice di rototraslazione} che rappresenta lo spostamento e la rotazione del dispositivo rispetto al sistema di riferimento, e viene moltiplicato il vettore delle coordinate di ogni singolo punto per la matrice generata. \\
In questo modo si sono ridotti i tempi di elaborazione dell'80\%;
\newline

\noindent
Il secondo problema era causato dal sovrapporsi di molti punti quasi identici, ad esempio i punti rappresentanti il pavimento. Partendo dall'osservazione che una certa quantità di punti molto vicini può essere trasformata in un unico punto, valore medio di tutti gli altri, senza una significativa perdita d'informazione, \emph{Samba} risolve il problema attraverso una tecnica di \emph{voxeling}.\\
Lo spazio viene suddiviso in tanti piccoli parallelepipedi (tipicamente cubi) di uguali dimensioni; tutti i punti che ricadono all'interno di un singolo parallelepipedo, o \emph{voxel}, vengono considerati come un unico punto. Così facendo si riducono sensibilmente le dimensioni del \emph{Point Cloud} senza alterarne negativamente la precisione.
Di seguito la differenza visivamente evidente tra lo stesso Point Cloud filtrato prima con voxel cubici di lato 1cm (fig. \ref{fig:low_voxeling}) e poi di lato 3cm (fig. \ref{fig:high_voxeling}), con una differenza di circa 60.000 punti rimossi in più nella seconda elaborazione.
\begin{figure}[htp] 
    \centering
    \subfloat[Voxeling leggero]{%
        \includegraphics[width=0.47\columnwidth]{varie/low_voxeling.png} 
    	\label{fig:low_voxeling}
    }%
    \hfill%
    \subfloat[Voxeling elevato]{%
        \includegraphics[width=0.47\columnwidth]{varie/high_voxeling.png} 
    	\label{fig:high_voxeling}
    }%
    \caption{Effetti del \emph{voxeling}}
\end{figure}
\newline

\subsubsection{Visualizzatore di mesh}
Nel prototipo è stata introdotta la possibilità di caricare e visualizzare le \emph{mesh} risultato dell'elaborazione lato server di un \emph{Point Cloud}.
Una \emph{mesh} poligonale è una collezione di vertici, spigoli e facce che definiscono la forma di un oggetto poliedrico; in \emph{Samba} è ottenuta a partire dalla nuvola di punti elaborata.
Tale \emph{mesh} viene salvata dal \emph{server} in formato \emph{OBJ}, comunemente usato nelle applicazioni 3D. Dall'applicazione viene quindi richiesto di caricare e salvare nella memoria locale del tablet le mesh disponibili sul server, per poi poter essere visualizzate ed esaminate.


\subsection{L'applicativo attuale: VIC-Tango}
L'ultimo prototipo si avvicina già ad uno stato più stabile e funzionale e si pone come base su cui sviluppare l'applicazione in futuro. VIC-Tango è una versione rifinita e migliorata di \emph{Samba}, della quale sono stati risolti svariati bug, immancabili allo stadio prototipale. Introduce inoltre alcune nuove funzionalità che migliorano la User experience e lasciano la porta aperta a sviluppi futuri.

\subsubsection{Firebase}
\emph{Firebase} è un \emph{framework} associato all'omonimo \emph{web service} offerto da \emph{Google} per lo scambio di messaggi tra applicazioni \emph{Android} e un \emph{server}. In particolare è stato utlizzato il servizio \emph{Firebase} di cloud messaging per la gestione e invio affidabile di messaggi a più dispositivi differenti.\\ Il suo utilizzo in VIC-Tango ha permesso di implementare un servizio di notifica da parte del server, che può così inviare messaggi asincroni al device Tango, il quale li riceverà come notifica di sistema Android, informandolo ad esempio che il Point Cloud inviato è stato elaborato e una nuova mesh è stata generata. L'utente può così continuare l'ispezione e acquisire nuovi Point Cloud e, alla ricezione della notifica, caricare e visualizzare automaticamente le mesh quando disponibili.

\subsubsection{Camera preview}
Fin dal prototipo precedente era stata introdotta una piccola preview di quanto ripreso dalla fotocamera RGB-IR. Tuttavia la funzionalità era stata implementata utilizzando una soluzione general-purpose applicabile a più dispositivi Android, che causava però problemi prestazionali e crash occasionali dell'applicativo. \\
La preview è stata quindi reimplementata utilizzando le funzionalità esposte dalle Tango API, soluzione inizialmente scartata perchè quest'ultime erano mal documentate, ottenendo un miglioramento delle prestazioni e la correzione dei bug rilevati.

\subsubsection{JNI e Point Cloud Registration}
La Java Native Interface o JNI è un framework del linguaggio Java che consente al codice Java di richiamare codice cosiddetto "nativo", ovvero specifico di un determinato sistema operativo scritto in altri linguaggi di programmazione, in particolare C/C++.\\
L'integrazione della JNI con lo sviluppo Android, in particolare il suo utilizzo nell'IDE Android Studio, è un compito tutt'altro che semplice, dato il supporto ancora scarso all'integrazione del framework con l'IDE e il build-tool Gradle.\\
Dopo svariati tentativi iniziati già i primi giorni di stage, quindi già dai prototipi precedenti, è stato infine possibile usufruire della JNI utilizzando versioni sperimentali di Android Studio e Gradle. \\
Attraverso la JNI si è provato ad importare la libreria PCL, così da poterne utilizzare le potenti funzionalità direttamente dal tablet. Purtroppo l'integrazione con il build-tool Gradle richiede un makefile apposito, compito improponibile per una libreria notevolmente complessa come PCL, le cui potenzialità sono quindi rimaste nel lato server.\\
Si è riuscito invece ad importare, date le ridotte dimensioni, una libreria per la \emph{Registration} di Point Cloud. Col termine \emph{Registration} s'indica il processo che trasforma in coordinate assolute e allinea due set di Point Cloud in un unico set che minimizza le distanze tra punti corrispondenti (ad es. fig. \ref{fig:reg_example}).
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/registration_example.png} 
    \caption{\emph{Point Cloud Registration} tramite l'algoritmo \emph{ICP}}
    \label{fig:reg_example}
\end{figure}
\newline
La libreria in questione, GOICP, implementa una versione ottimizzata dell'algoritmo ICP (Iterative Closest Point), spesso utilizzato in applicazioni nelle quali sia necessario ricostruire una superficie tridimensionale a partire da più scansioni, che punta a minimizzare la distanza tra i punti delle due Point Cloud.\\
L'algoritmo ICP tenta di minimizzare l'errore quadratico medio (in inglese Mean Squared Error, MSE) cioè la discrepanza quadratica media fra i valori dei punti della coppia di Point Cloud, definita come:
$$
	MSE = \displaystyle\frac{\sum_{i=1}^{n} (x_i - x'_i)^2}{ n }
$$
Si è testato GOICP sulle coppie di Point Cloud acquisite con VIC-Tango, per ovviare al problemi già presentati del \emph{drifting} (fig. \ref{fig:no_drift_correction}) e del \emph{ghosting} (fig. \ref{fig:with_drift_correction}); si sono ottenuti però risultati insoddisfacenti. Sono sorti infatti i seguenti problemi:
\begin{itemize}
\item Il processo è eccessivamente dispendioso da effettuare su tablet, con tempi di elaborazione tra i 10 e i 60 secondi.
\item L'algoritmo ICP, basandosi sul MSE come valore di bontà, converge spesso lentamente e  a soluzioni errate, per colpa della grande quantità di punti planari sul pavimento, che rendono l'errore quadratico medio un valore non attendibile su cui basare il successo di una \emph{Registration} 
\end{itemize}
Come si vede in figura \ref{fig:goicp} l'algoritmo, pur ottenendo un basso valore di MSE, non effettua la \emph{Registration} desiderata, dato che vengono allineati perlopiù i punti planari.
\begin{figure}[htp] 
    \centering
    \subfloat[Prima scansione]{%
        \includegraphics[width=0.5\columnwidth]{varie/to_align_left.png} 
    	\label{fig:goicp_left}
    }%
    \hfill%
    \subfloat[Seconda scansione]{%
        \includegraphics[height=0.42\columnwidth]{varie/to_align_right.png} 
    	\label{fig:goicp_right}
    }%
    \hfill%
    \subfloat[Risultato di GOIPC]{%
        \includegraphics[width=0.6\columnwidth]{varie/goicp.png} 
    	\label{fig:goicp}
    }%
    \caption{Errore nella \emph{Registration} con \emph{GOICP}}
\end{figure}
\newline

\noindent
Per questi motivi GOICP non potrà essere utilizzata nei futuri prototipi, se non si effettuerà alemeno una delle seguenti correzioni:
\begin{itemize}
\item Trovare una misura più adatta del MSE per valutare la convergenza dell'algoritmo ICP
\item Alternativamente, eliminare dal Point Cloud i punti planari appartenenti al pavimento così da poter utilizzare l'errore quadratico medio come affidabile valore di convergenza
\item Ottimizzare GOICP o implementare in algoritmo ICP ad hoc per ridurre drasticamente i tempi di elaborazione
\end{itemize}
\noindent
Tali correzioni trattano problemi non triviali, che l'esiguo tempo di tirocinio rimasto non mi ha permesso di affrontare adeguatamente. La Point Cloud Registration rimane quindi una funzionalità necessaria ad assicurare un'affidabile e corretta ricostruzione degli oggetti scansionati, che dovrà essere implementata nei futuri prototipi.




\newpage

%**************************************************************
\section{Il Prodotto - lato server}
Il lato server dell'applicazione si occupa di ricevere dai \emph{Tango device} i Point Cloud acquisiti, elaborarli utilizzando la libreria PCL per estrarre i punti rappresentanti il solo oggetto scansionato, produrre una mesh dell'oggetto così ottenuto e calcolarne il volume. Invia poi quando necessario i risultati elaborati ai dispositivi che li richiedono.\\
Quando un Point Cloud viene ricevuto dal server tramite una richiesta HTTP POST, inserito in un oggetto JSON, viene salvato in un file PCD. Il formato PCD (Point Cloud Data) usato nella libreria PCL è molto semplice: è formato da un header contenente alcune informazioni utili come il numero totale di punti e il tipo e numero di valori associati ad ogni punto; segue poi l'effettivo Point Cloud codificato riga per riga, dove ogni riga contiene una successione di valori che rappresenta un punto.\\
Il file salvato viene poi elaborato sfruttando la libreria PCL.

\subsection{Point Cloud Library}
\emph{PCL} o \emph{Point Cloud Library} è una libreria \emph{Open Source}, scritta in C++, di algoritmi per l'elaborazione di \emph{Point Cloud} tridimensionali. Contiene algoritmi per il filtraggio, la segmentazione, la \emph{registration} e il \emph{meshing} di Point Cloud, per citarne alcuni. \\
La libreria è ampiamente utilizzata da qualsiasi applicativo debba trattare nuvole di punti, ed oltre ad essere utile ed efficiente è anche ben documentata, con molti esempi d'utilizzo reperibili online.\\
Le notevoli potenzialità della libreria sono state utilizzate intensivamente nell'applicativo con lo scopo di isolare i punti appartenenti all'oggetto scansionato dal resto del Point Cloud, ed effettuarne quindi il meshing.

\subsection{Elaborazione di un Point Cloud}

La nuvola di punti salvata in un file PCD viene elaborata da un applicativo scritto in C++ che sfrutta le numerose funzionalità della PCL.
L'elaborazione di un Point Cloud è composta di più passi sequenziali:
\begin{enumerate}
\item Viene caricato il nuovo Point Cloud da file PCD salvato localmente
\item Vengono rimossi i punti isolati della nuvola attraverso la libreria Sparse Filtering
\item Vengono rimossi i punti troppo esterni della nuvola attraverso la libreria Radius Filtering 
\item Vengono rimossi i punti che corrispondono al piano del pavimento attraverso la libreria Ground Filtering
\item Viene effettuato il \emph{downsample} del \emph{dataset} attraverso la libreria Voxel Filtering
\item Viene estratto il cluster maggiore dai punti rimanenti attraverso la libreria Cluster Extraction
\item Viene effettuato il meshing del cluster estratto, e la mesh viene salvata in due file OBJ (per la visualizzazione lato client) e VTK (per il calcolo del volume)
\item Viene calcolato e salvato il volume della mesh prodotta
\end{enumerate}
Per ogni passo di filtraggio la nuvola di punti viene salvata su un distinto file PCD, per poter analizzare visivamente la bontà dell'elaborazione.
Di seguito vengono descritti in dettaglio filtri applicati e il processo di meshing.

\subsubsection{Sparse filtering}
Questo primo passo di filtraggio si occupa di rimuovere dal Point Cloud i punti isolati. Per ogni punto viene effettuata una analisi statistica della distanza media dai suoi vicini. I punti la cui distanza dai vicini supera un certo valore sono quindi isolati e possono essere eliminati dalla nuvola.
Un esempio di tale tecnica, sul quale si basa l'implementazione di questo filtro, è lo "Statistical Outlier Removal\footcite{http://pointclouds.org/documentation/tutorials/statistical_outlier.php/statistical-outlier-removal}" di PCL.\\
In figura \ref{fig:sparse} vediamo i risultati di tale filtro, con una rimozione di circa 10.000 punti.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/sparse.png} 
    \caption{\emph{Sparse filtering}}
    \label{fig:sparse}
\end{figure}
\subsubsection{Radius filtering}
Questo passo di filtraggio si occupa di eliminare i punti troppo distanti dal centro, che solitamente appartengono alle pareti circostanti o comunque ad oggetti diversi da quello scansionato, che sarà sempre verso il centro della nuvola.\\
Partendo da questo presupposto, il filtro calcola il punto centrale del Point Cloud, media del valore di tutti i punti, e procede con l'eliminare i punti che superano una certa distanza (\emph{radius}), attraverso l'algoritmo PCL "PassThrough Filter\footcite{http://pointclouds.org/documentation/tutorials/passthrough.php/passthrough}", fino a che non è stata eliminata una definita percentuale del point set iniziale.\\
In figura \ref{fig:radius} vediamo i risultati di tale filtro, con una rimozione di circa 24.000 punti.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/radius.png} 
    \caption{\emph{Radius filtering}}
    \label{fig:radius}
\end{figure}
\subsubsection{Ground filtering}
Questo passo di filtraggio si occupa di eliminare i punti planari appartenenti al pavimento, problema che si è rilevato essere uno dei più difficili da trattare. 
In primo luogo non sempre c'è un unico componente planare che rappresenta il pavimento, ma solitamente ve n'è più d'uno, a causa delle imprecisioni nell'acquisizione dei Point Cloud lato client. Per l'implementazione del filtro si è fatto uso degli algoritmi di \emph{segmentation} di PCL (ad es. "Planar segmentation\footcite{http://pointclouds.org/documentation/tutorials/planar_segmentation.php}"), che consentono di estrarre i punti della nuvola che giacciono sullo stesso piano. Senza ulteriori aggiustamenti però l'algoritmo elimina anche piani utili, come il lato superiore di una scatola o di un tavolo.
Si è reso quindi necessario applicare i seguenti passi:
\begin{enumerate}
\item Calcolare l'altezza del Point Cloud e dividere la parte superiore da quella inferiore, che deve contenere il pavimento
\item Applicare l'algoritmo di \emph{planar segmentation} alla sotto-nuvola estratta fino a che non è stato eliminato un numero adeguato di punti
\item Ricongiungere la parte inferiore filtrata alla parte superiore del Point Cloud
\end{enumerate}
Il filtro così impostato ottiene ottimi risultati nella maggior parte dei casi. Tuttavia se il Point Cloud originale presenta troppo  \emph{drifting}, e i piani del pavimento sono molto distanti tra loro, diventa impossibile eliminarli senza togliere anche punti importanti dell'oggetto scansionato.\\
In figura \ref{fig:ground} vediamo i risultati di tale filtro, applicato ad un Point Cloud già sottoposto ai filtri precedenti, con una rimozione di circa 50.000 punti.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/ground.png} 
    \caption{\emph{Ground filtering}}
    \label{fig:ground}
\end{figure}

\subsubsection{Voxel filtering}
Questo passo di filtraggio si occupa di eliminare i punti doppi e ridurre le dimensioni del Point Cloud per il futuro meshing. Il filtro utilizza la stessa tecnica già implementata nel lato client, cioè suddividere lo spazio in tanti \emph{voxel} cubici e  calcolare il punto medio di ogni voxel come approssimazione dei punti che ricadono al suo interno. L'implemetazione prende spunto dall'esempio di PCL "VoxelGrid Filter\footcite{http://pointclouds.org/documentation/tutorials/voxel_grid.php}".
Per i risultati del \emph{voxel filtering} si rimanda alle figure \ref{fig:low_voxeling} e \ref{fig:high_voxeling}.
\subsubsection{Cluster extraction}
L'ultimo passaggio prima del meshing è il \emph{Cluster extraction}, cioè il completo isolamento della nuvola di punti rappresentante oggetto in ispezione.
L'algoritmo PCL "\emph{Euclidean Cluster Extraction\footcite{http://www.pointclouds.org/documentation/tutorials/cluster_extraction.php}}" su cui si base quest'ultimo step di filtraggio suddivide lo spazio del Point Cloud in più parti ed analizzandone statisticamente la densità per ogni parte, riesce a determinare quali sono  gli aggregati di punti nella nuvola, distinguibili gli uni dagli altri.
L'algoritmo suddivide quindi la nuvola in più cluster, e ne estrae quello di maggiori dimensioni. Questo filtraggio finale indispensabile al passo successivo di meshing, perchè elimina dal Point Cloud tutti gli elementi estranei all'oggetto.\\
In figura \ref{fig:cluster} vediamo i risultati di tale filtro, applicato ad un Point Cloud già sottoposto ai filtri precedenti, con una rimozione di circa 4.000 punti. Sono evidenziati in figura alcuni piccoli gruppi di punti che è necessario eliminare, che rappresentano degli artefatti inesistenti nel mondo reale, ma che sono immancabilmente presenti nelle scansioni di un oggetto. L'origine di tali anomalie non è ancora chiara, probabilmente sono causate da riflessi del pavimento.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/cluster.png} 
    \caption{\emph{Cluster extraction}}
    \label{fig:cluster}
\end{figure}

\subsubsection{Meshing}
Una volta ottenuti i punti della nuvola rappresentanti il solo oggetto scansionato, si può procedere col generarne una mesh tridimensionale.
Il processo sfrutta un algoritmo greedy di PCL, la "\emph{Greedy Projection Triangulation\footcite{http://www.pointclouds.org/documentation/tutorials/greedy_projection.php}}", che, connettendo ogni punto ai propri vicini, genera un mesh composta da migliaia di triangoli che approssima la superficie reale dell'oggetto.
In figura \ref{fig:mesh} vediamo i risultati del processo di meshing applicato ad un Point Cloud già sottoposto ai filtri precedenti.
\begin{figure}[!h] 
    \centering 
    \includegraphics[width=1.0\columnwidth]{varie/mesh.png} 
    \caption{\emph{Meshing} di un \emph{Point Cloud}}
    \label{fig:mesh}
\end{figure}
\newline
La mesh così ottenuta non è una superficie chiusa, spesso infatti le scansioni non riescono a catturare tutti i punti di un oggetto, e manca completamente il piano di base dell'oggetto scansionato, che non è possibile rilevare. Ciò non influisce particolarmente sul successivo calcolo del volume.

\subsection{Calcolo del volume}
Una volta generata la mesh è possibile calcolarne il volume sfruttando il risultato pubblicato da Cha Zhang e Tsuhan Chen nel loro paper "EFFICIENT FEATURE EXTRACTION FOR 2D/3D OBJECTS IN MESH REPRESENTATION \footcite{http://research.microsoft.com/en-us/um/people/chazhang/publications/icip01_ChaZhang.pdf}". Viene calcolato, per ogni triangolo che compone la \emph{mesh}, il volume con segno del tetraedro che ha il triangolo stesso come base e il quarto vertice in un punto fissato, scelto internamente alla \emph{mesh}, per evitare eventuali problemi di instabilità numerica. Il segno del volume è dato dalla direzione della normale al piano del triangolo. Questi volumi, sommati tra loro, restituiscono il volume convesso della \emph{mesh}.\\
Il calcolo del volume, nella sua semplicità e velocità d'elaborazione, pone però delle condizioni sulla qualità della mesh:
\begin{itemize}
\item La superficie non necessita di essere chiusa, ma il calcolo ne beneficierebbe
\item Il punto scelto come quarto vertice del tetraedro deve appartenere alla mesh
\item La mesh non deve contenere triangoli che si sovrappongono o si intersecano
\end{itemize}
La bontà del calcolo dipende quindi molto dalla qualità del Point Cloud prima del meshing, che dev'essere quanto più assente da fenomeni di \emph{ghosting}, \emph{drifting} e in generale da artefatti e punti sparsi che non riflettono la vera forma dell'oggetto ispezionato.

%**************************************************************
\section{Lavoro svolto}
Al tirocinante è stato richiesto di focalizzarsi sullo sviluppo del lato server dell'applicazione, in modo che fosse possibile ricevere ed elaborare Point Cloud, ed ottenere i risultati elaborati, lavorando nel mentre in stretta collaborazione con un altro stagista che si occupava dell'applicazione lato client. Nell'ultimo periodo di stage la parte server era già a buon punto, quindi il focus del tirocinio si è spostato sul miglioramento dell'applicativo lato client.


%**************************************************************
\section{Organizzazione del testo}
Riguardo la stesura del testo, relativamente al documento sono state adottate le seguenti convenzioni tipografiche:
\begin{itemize}
	\item gli acronimi, le abbreviazioni e i termini ambigui o di uso non comune menzionati vengono definiti nel glossario, situato alla fine del presente documento;
	\item per la prima occorrenza dei termini riportati nel glossario viene utilizzata la seguente nomenclatura: \emph{parola}\glsfirstoccur;
	\item i termini in lingua straniera o facenti parti del gergo tecnico sono evidenziati con il carattere \emph{corsivo}.
\end{itemize}